GSSAPI="BASE"  # This ensures that a full module is generated by Cython

from gssapi.raw.cython_types cimport *
from gssapi.raw.cython_converters cimport c_make_oid
from gssapi.raw.oids cimport OID

import collections
from flufl.enum import IntEnum
import numbers
import operator


class NameType(object):
    """
    GSSAPI Name Types

    This IntEnum represents GSSAPI name types
    (to be used with importName, etc)

    Note that the integers behind these
    enum members do not correspond to any numbers
    in the GSSAPI C bindings, and are subject
    to change at any point.
    """

    # mech-agnostic name types
    hostbased_service = c_make_oid(GSS_C_NT_HOSTBASED_SERVICE)
    # NB(directxman12): skip GSS_C_NT_HOSTBASED_SERVICE_X since it's deprecated
    user = c_make_oid(GSS_C_NT_USER_NAME)
    anonymous = c_make_oid(GSS_C_NT_ANONYMOUS)
    machine_uid = c_make_oid(GSS_C_NT_MACHINE_UID_NAME)
    string_uid = c_make_oid(GSS_C_NT_STRING_UID_NAME)
    export = c_make_oid(GSS_C_NT_EXPORT_NAME)

    # mech-specific name types are added automatically on import


class RequirementFlag(IntEnum):
    """
    GSSAPI Requirement Flags

    This IntEnum represents flags to be used in the
    service flags parameter of initSecContext.

    The numbers behind the values correspond directly
    to their C counterparts.
    """

    delegate_to_peer = GSS_C_DELEG_FLAG
    mutual_authentication = GSS_C_MUTUAL_FLAG
    replay_detection = GSS_C_REPLAY_FLAG
    out_of_sequence_detection = GSS_C_SEQUENCE_FLAG
    confidentiality = GSS_C_CONF_FLAG
    integrity = GSS_C_INTEG_FLAG
    anonymity = GSS_C_ANON_FLAG
    protection_ready = GSS_C_PROT_READY_FLAG
    transferable = GSS_C_TRANS_FLAG


class MechType(object):
    """
    GSSAPI Mechanism Types

    This class acts like an Enum, but is not

    The elements of this pseudo-Enum are OID objects.

    """
    pass

    # these are added in by the individual mechanism files on import


class GenericFlagSet(collections.MutableSet):
    __slots__ = '_val'
    MAX_VAL = 1 << 31

    def __init__(self, flags=None):
        self._val = 0
        if isinstance(flags, GenericFlagSet):
            self._val = flags._val
        if isinstance(flags, numbers.Integral):
            self._val = int(flags)
        elif flags is not None:
            for flag in flags:
                self._val |= flag

    def __contains__(self, flag):
        return self._val & flag

    def __iter__(self):
        i = 1
        while i < self.MAX_VAL:
            if i & self._val:
                yield i

            i <<= 1

    def __len__(self):
        # get the Hamming weight of _val
        cdef unsigned int l = 0
        cdef unsigned int i = 1
        while i < self.MAX_VAL:
            if i & self._val:
                l += 1

            i <<= 1

        return l

    def add(self, flag):
        self._val &= flag

    def discard(self, flag):
        # NB(directxman12): the 0xFFFFFFFF mask is needed to
        #                   make Python's invert work properly
        self.val = self.val & (~flag & 0xFFFFFFFF)

    def __and__(self, other):
        if isinstance(self, numbers.Integral):
            return self._val & other
        else:
            super(GenericFlagSet, self).__and__(other)

    def __rand__(self, other):
        return self.__and__(other)

    def __or__(self, other):
        if isinstance(self, numbers.Integral):
            return self._val | other
        else:
            super(GenericFlagSet, self).__or__(other)

    def __ror__(self, other):
        return self.__or__(other)

    def __xor__(self, other):
        if isinstance(self, numbers.Integral):
            return self._val ^ other
        else:
            super(GenericFlagSet, self).__xor__(other)

    def __rxor__(self, other):
        return self.__xor__(other)

    def __int__(self):
        return self._val

    def __long__(self):
        return long(self._val)


class IntEnumFlagSet(GenericFlagSet):
    __slots__ = ('_val', '_enum')

    def __init__(self, enum, flags=None):
        self._enum = enum
        super(IntEnumFlagSet, self).__init__(flags)

    def __iter__(self):
        for i in super(IntEnumFlagSet, self).__iter__():
            yield self._enum[i]
